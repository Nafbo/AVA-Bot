"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitters = void 0;
const tsparticles_engine_1 = require("tsparticles-engine");
const Emitter_1 = require("./Options/Classes/Emitter");
const EmitterInstance_1 = require("./EmitterInstance");
class Emitters {
    constructor(engine, container) {
        this.container = container;
        this._engine = engine;
        this.array = [];
        this.emitters = [];
        this.interactivityEmitters = {
            random: {
                count: 1,
                enable: false,
            },
            value: [],
        };
        container.getEmitter = (idxOrName) => idxOrName === undefined || typeof idxOrName === "number"
            ? this.array[idxOrName || 0]
            : this.array.find((t) => t.name === idxOrName);
        container.addEmitter = (options, position) => this.addEmitter(options, position);
        container.removeEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                this.removeEmitter(emitter);
            }
        };
        container.playEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                emitter.externalPlay();
            }
        };
        container.pauseEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                emitter.externalPause();
            }
        };
    }
    addEmitter(options, position) {
        const emitterOptions = new Emitter_1.Emitter();
        emitterOptions.load(options);
        const emitter = new EmitterInstance_1.EmitterInstance(this._engine, this, this.container, emitterOptions, position);
        this.array.push(emitter);
        return emitter;
    }
    handleClickMode(mode) {
        const emitterOptions = this.emitters, modeEmitters = this.interactivityEmitters;
        if (mode !== "emitter") {
            return;
        }
        let emittersModeOptions;
        if (modeEmitters && modeEmitters.value instanceof Array) {
            if (modeEmitters.value.length > 0 && modeEmitters.random.enable) {
                emittersModeOptions = [];
                const usedIndexes = [];
                for (let i = 0; i < modeEmitters.random.count; i++) {
                    const idx = (0, tsparticles_engine_1.arrayRandomIndex)(modeEmitters.value);
                    if (usedIndexes.includes(idx) && usedIndexes.length < modeEmitters.value.length) {
                        i--;
                        continue;
                    }
                    usedIndexes.push(idx);
                    emittersModeOptions.push((0, tsparticles_engine_1.itemFromArray)(modeEmitters.value, idx));
                }
            }
            else {
                emittersModeOptions = modeEmitters.value;
            }
        }
        else {
            emittersModeOptions = modeEmitters === null || modeEmitters === void 0 ? void 0 : modeEmitters.value;
        }
        const emittersOptions = emittersModeOptions !== null && emittersModeOptions !== void 0 ? emittersModeOptions : emitterOptions, ePosition = this.container.interactivity.mouse.clickPosition;
        (0, tsparticles_engine_1.executeOnSingleOrMultiple)(emittersOptions, (emitter) => {
            this.addEmitter(emitter, ePosition);
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emitters = this.container.actualOptions.emitters;
            this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters;
            if (!this.emitters) {
                return;
            }
            if (this.emitters instanceof Array) {
                for (const emitterOptions of this.emitters) {
                    this.addEmitter(emitterOptions);
                }
            }
            else {
                this.addEmitter(this.emitters);
            }
        });
    }
    pause() {
        for (const emitter of this.array) {
            emitter.pause();
        }
    }
    play() {
        for (const emitter of this.array) {
            emitter.play();
        }
    }
    removeEmitter(emitter) {
        const index = this.array.indexOf(emitter);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
    resize() {
        for (const emitter of this.array) {
            emitter.resize();
        }
    }
    stop() {
        this.array = [];
    }
    update(delta) {
        for (const emitter of this.array) {
            emitter.update(delta);
        }
    }
}
exports.Emitters = Emitters;
